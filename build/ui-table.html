<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-list` displays a virtual, 'infinite' list. The template inside the 
`core-list` element represents the dom to create for each list item. The
`data` property specifies an array of list item data. The `height` property
represents the height of a list item.

By default, the list supports selection via tapping. Styling the selection 
should be done via binding. The `selectedProperty` property is set on the 
list view data for each selected item.

`core-list` manages a viewport of data based on the current scroll position.
For performance reasons, not every item in the list is rendered at once.

    <core-list data="{{data}}" height="80">
      <template>
        <div class="{{ {selected: selected} | tokenList }}">List row: {{index}}</div>
      </template>
    </core-list>

@group Polymer Core Elements
@element core-list
-->
<!-- did not import ../polymer/polymer.html-->
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
@group Polymer Core Elements

The `<core-selection>` element is used to manage selection state. It has no
visual appearance and is typically used in conjunction with another element.
For example, [core-selector](#core-selector)
use a `<core-selection>` to manage selection.

To mark an item as selected, call the `select(item)` method on 
`<core-selection>`. The item itself is an argument to this method.

The `<core-selection>`element manages selection state for any given set of
items. When an item is selected, the `core-select` event is fired.

The attribute `multi` indicates if multiple items can be selected at once.
  
Example:
 
    <polymer-element name="selection-example">
       <template>
         <style>
           polyfill-next-selector { content: ':host > .selected'; }
           ::content > .selected {
             font-weight: bold;
             font-style: italic;
           }
         </style>
         <ul on-tap="{{itemTapAction}}">
           <content></content>
         </ul>
         <core-selection id="selection" multi
                         on-core-select="{{selectAction}}"></core-selection>
       </template>
       <script>
         Polymer('selection-example', {
           itemTapAction: function(e, detail, sender) {
             this.$.selection.select(e.target);
           },
           selectAction: function(e, detail, sender) {
             detail.item.classList.toggle('selected', detail.isSelected);
           }
         });
       </script>
    </polymer-element>

    <selection-example>
      <li>Red</li>
      <li>Green</li>
      <li>Blue</li>
    </selection-example>
 
@element core-selection
-->

<!--
Fired when an item's selection state is changed. This event is fired both
when an item is selected or deselected. The `isSelected` detail property
contains the selection state.

@event core-select
@param {Object} detail
  @param {boolean} detail.isSelected true for selection and false for de-selection
  @param {Object} detail.item the item element
-->
<!-- did not import ../polymer/polymer.html-->

<polymer-element name="core-selection" attributes="multi" hidden>
  <script>
    Polymer('core-selection', {
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      ready: function() {
        this.clear();
      },
      clear: function() {
        this.selection = [];
      },
      /**
       * Retrieves the selected item(s).
       * @method getSelection
       * @returns Returns the selected item(s). If the multi property is true,
       * getSelection will return an array, otherwise it will return 
       * the selected item or undefined if there is no selection.
      */
      getSelection: function() {
        return this.multi ? this.selection : this.selection[0];
      },
      /**
       * Indicates if a given item is selected.
       * @method isSelected
       * @param {any} item The item whose selection state should be checked.
       * @returns Returns true if `item` is selected.
      */
      isSelected: function(item) {
        return this.selection.indexOf(item) >= 0;
      },
      setItemSelected: function(item, isSelected) {
        if (item !== undefined && item !== null) {
          if (isSelected) {
            this.selection.push(item);
          } else {
            var i = this.selection.indexOf(item);
            if (i >= 0) {
              this.selection.splice(i, 1);
            }
          }
          this.fire("core-select", {isSelected: isSelected, item: item});
        }
      },
      /**
       * Set the selection state for a given `item`. If the multi property
       * is true, then the selected state of `item` will be toggled; otherwise
       * the `item` will be selected.
       * @method select
       * @param {any} item: The item to select.
      */
      select: function(item) {
        if (this.multi) {
          this.toggle(item);
        } else if (this.getSelection() !== item) {
          this.setItemSelected(this.getSelection(), false);
          this.setItemSelected(item, true);
        }
      },
      /**
       * Toggles the selection state for `item`.
       * @method toggle
       * @param {any} item: The item to toggle.
      */
      toggle: function(item) {
        this.setItemSelected(item, !this.isSelected(item));
      }
    });
  </script>
</polymer-element>


<polymer-element name="core-list" on-tap="{{tapHandler}}">
<template>
  <core-selection id="selection" multi="{{multi}}" on-core-select="{{selectedHandler}}"></core-selection>
  <style>/*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
:host {
  display: block;
  overflow: auto;
}
.core-list-viewport > * {
  overflow: hidden;
}
.core-list-viewport.horizontal {
  height: 100%;
  white-space: nowrap;
}
.core-list-viewport.horizontal > * {
  display: inline-block;
}
/* Setting will-change: transform on the #viewport makes the viewport a
   stacking context, which causes all the composited layers inside the
   viewport to actually be stacked underneath the viewport. */
#viewport {
  will-change: transform;
}
</style>
  <div id="viewport" class="core-list-viewport"><content></content></div>
</template>
<script>
(function() {

  Polymer('core-list', {
    
    publish: {
      /**
       * Fired when an item element is tapped.
       * 
       * @event core-activate
       * @param {Object} detail
       *   @param {Object} detail.item the item element
       */

      /**
       * 
       * An array of source data for the list to display.
       *
       * @attribute data
       * @type array
       * @default null
       */
      data: null,

      /**
       * 
       * An optional element on which to listen for scroll events.
       *
       * @attribute scrollTarget
       * @type Element
       * @default core-list
       */
      scrollTarget: null,

      /**
       * 
       * The height of a list item. `core-list` currently supports only fixed-height
       * list items. This height must be specified via the height property.
       *
       * @attribute height
       * @type number
       * @default 80
       */
      height: 80,

      /**
       * 
       * The number of extra items rendered above the minimum set required to
       * fill the list's height.
       *
       * @attribute extraItems
       * @type number
       * @default 30
       */
      extraItems: 30,

      /**
       * 
       * The property set on the list view data to represent selection state. 
       * This should set so that it does not conflict with other data properties.
       * Note, selection data is not stored on the data in given in the data property.
       *
       * @attribute selectedProperty
       * @type string
       * @default 'selected'
       */
      selectedProperty: 'selected',

      // TODO(sorvell): experimental
      /**
       * 
       * If true, data is sync'd from the list back to the list's data.
       *
       * @attribute sync
       * @type boolean
       * @default false
       */
      sync: false,

      /**
       * 
       * Set to true to support multiple selection.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false

    },
    
    observe: {
      'data template scrollTarget': 'initialize'
    },

    ready: function() {
      this.clearSelection();
      this._boundScrollHandler = this.scrollHandler.bind(this);
    },

    attached: function() {
      this.template = this.querySelector('template');
    },

    // TODO(sorvell): it'd be nice to dispense with 'data' and just use 
    // template repeat's model. However, we need tighter integration
    // with TemplateBinding for this.
    initialize: function() {
      if (!this.data || !this.template) {
        return;
      }
      var target = this.scrollTarget || this;
      if (this._target !== target) {
        if (this._target) {
          this._target.removeEventListener('scroll', this._boundScrollHandler, false);
        }
        this._target = target;
        this._target.addEventListener('scroll', this._boundScrollHandler, false);
      }

      this.initializeViewport();
      this.initalizeData();
      this.onMutation(this, this.initializeItems);
    },

    // TODO(sorvell): need to handle resizing
    initializeViewport: function() {
      this.$.viewport.style.height = this.height * this.data.length + 'px';
      this._visibleCount = Math.ceil(this._target.offsetHeight / this.height);
      this._physicalCount = Math.min(this._visibleCount + this.extraItems,
          this.data.length);
      this._physicalHeight = this.height * this._physicalCount;
    },

    // TODO(sorvell): selection currently cannot be maintained when
    // items are added or deleted.
    initalizeData: function() {
      var exampleDatum = this.data[0] || {};
      this._propertyNames = Object.getOwnPropertyNames(exampleDatum);
      this._physicalData = new Array(this._physicalCount);
      for (var i = 0; i < this._physicalCount; ++i) {
        this._physicalData[i] = {};
        this.updateItem(i, i);
      }
      this.template.model = this._physicalData;
      this.template.setAttribute('repeat', '');
    },

    initializeItems: function() {
      this._physicalItems = new Array(this._physicalCount);
      for (var i = 0, item = this.template.nextElementSibling;
           item && i < this._physicalCount;
           ++i, item = item.nextElementSibling) {
        this._physicalItems[i] = item;
        item._transformValue = 0;
      }
      this.refresh(false);
    },

    updateItem: function(virtualIndex, physicalIndex) {
      var virtualDatum = this.data[virtualIndex];
      var physicalDatum = this._physicalData[physicalIndex];
      this.pushItemData(virtualDatum, physicalDatum);
      physicalDatum._physicalIndex = physicalIndex;
      physicalDatum._virtualIndex = virtualIndex;
      if (this.selectedProperty) {
        physicalDatum[this.selectedProperty] = this._selectedData.get(virtualDatum);
      }
    },

    pushItemData: function(source, dest) {
      for (var i = 0; i < this._propertyNames.length; ++i) {
        var propertyName = this._propertyNames[i];
        dest[propertyName] = source[propertyName];
      }
    },

    // experimental: push physical data back to this.data.
    // this is optional when scrolling and needs to be called at other times.
    syncData: function() {
      if (this.firstPhysicalIndex === undefined || 
          this.baseVirtualIndex === undefined) {
        return;
      }
      var p, v;
      for (var i = 0; i < this.firstPhysicalIndex; ++i) {
        p = this._physicalData[i];
        v = this.data[this.baseVirtualIndex + this._physicalCount + i];
        this.pushItemData(p, v);
      }
      for (var i = this.firstPhysicalIndex; i < this._physicalCount; ++i) {
        p = this._physicalData[i];
        v = this.data[this.baseVirtualIndex + i];
        this.pushItemData(p, v);
      }
    },

    scrollHandler: function(e, detail) {
      this._scrollTop = e.detail ? e.detail.target.scrollTop : e.target.scrollTop;
      this.refresh(false);
    },

    /**
     * Refresh the list at the current scroll position.
     *
     * @method refresh
     */
    refresh: function(force) {
      var firstVisibleIndex = Math.floor(this._scrollTop / this.height);
      var visibleMidpoint = firstVisibleIndex + this._visibleCount / 2;

      var firstReifiedIndex = Math.max(0, Math.floor(visibleMidpoint - 
          this._physicalCount / 2));
      firstReifiedIndex = Math.min(firstReifiedIndex, this.data.length - 
          this._physicalCount);

      var firstPhysicalIndex = firstReifiedIndex % this._physicalCount;
      var baseVirtualIndex = firstReifiedIndex - firstPhysicalIndex;

      var baseTransformValue = Math.floor(this.height * baseVirtualIndex);
      var nextTransformValue = Math.floor(baseTransformValue + 
          this._physicalHeight);

      var baseTransformString = 'translate3d(0,' + baseTransformValue + 'px,0)';
      var nextTransformString = 'translate3d(0,' + nextTransformValue + 'px,0)';
      // TODO(sorvell): experiemental for sync'ing back to virtual data.
      if (this.sync) {
        this.syncData();
      }
      this.firstPhysicalIndex = firstPhysicalIndex;
      this.baseVirtualIndex = baseVirtualIndex;

      for (var i = 0; i < firstPhysicalIndex; ++i) {
        var item = this._physicalItems[i];
        if (force || item._transformValue != nextTransformValue) {
          this.updateItem(baseVirtualIndex + this._physicalCount + i, i);
          setTransform(item, nextTransformString, nextTransformValue);
        }
      }
      for (var i = firstPhysicalIndex; i < this._physicalCount; ++i) {
        var item = this._physicalItems[i];
        if (force || item._transformValue != baseTransformValue) {
          this.updateItem(baseVirtualIndex + i, i);
          setTransform(item, baseTransformString, baseTransformValue);
        }
      }
    },

    // list selection
    tapHandler: function(e) {
      if (e.target === this) {
        return;
      }
      if (this.sync) {
        this.syncData();
      }
      var n = e.target;
      var model = n.templateInstance && n.templateInstance.model;
      if (model) {
        var vi = model._virtualIndex, pi = model._physicalIndex;
        var data = this.data[vi], item = this._physicalItems[pi];
        this.$.selection.select(data);
        this.asyncFire('core-activate', {data: data, item: item});
      }
    },

    selectedHandler: function(e, detail) {
      if (this.selectedProperty) {
        var i$ = this.indexesForData(detail.item);
        // TODO(sorvell): we should be relying on selection to store the
        // selected data but we want to optimize for lookup.
        this._selectedData.set(detail.item, detail.isSelected);
        if (i$.physical >= 0) {
          this.updateItem(i$.virtual, i$.physical);
        }
      }
    },

    /**
     * Select the list item at the given index.
     *
     * @method selectItem
     * @param {number} index 
     */
    selectItem: function(index) {
      var data = this.data[index];
      if (data) {
        this.$.selection.select(data);
      }
    },

    /**
     * Set the selected state of the list item at the given index.
     *
     * @method setItemSelected
     * @param {number} index 
     * @param {boolean} isSelected 
     */
    setItemSelected: function(index, isSelected) {
      var data = this.data[index];
      if (data) {
        this.$.selection.setItemSelected(data, isSelected);
      }
    },

    indexesForData: function(data) {
      var virtual = this.data.indexOf(data);
      var physical = this.virtualToPhysicalIndex(virtual);
      return { virtual: virtual, physical: physical };
    },

    virtualToPhysicalIndex: function(index) {
      for (var i=0, l=this._physicalData.length; i<l; i++) {
        if (this._physicalData[i]._virtualIndex === index) {
          return i;
        }
      }
      return -1;
    },

    get selection() {
      return this.$.selection.getSelection();
    },

    selectedChanged: function() {
      this.$.selection.select(this.selected);
    },

    clearSelection: function() {
      this._selectedData = new WeakMap();
      if (this.multi) {
        var s$ = this.selection;
        for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {
          this.$.selection.setItemSelected(s, false);
        }
      } else {
        this.$.selection.setItemSelected(this.selection, false);
      }
      this.$.selection.clear();
    },

    scrollToItem: function(index) {
      this.scrollTop = index * this.height;
    }

  });

  // determine proper transform mechanizm
  if (document.documentElement.style.transform !== undefined) {
    var setTransform = function(element, string, value) {
      element.style.transform = string;
      element._transformValue = value;
    }
  } else {
    var setTransform = function(element, string, value) {
      element.style.webkitTransform = string;
      element._transformValue = value;
    }
  }

})();
</script>
</polymer-element>

<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
@group Polymer Core Elements

The `core-ajax` element exposes `XMLHttpRequest` functionality.

    <core-ajax
        auto
        url="http://gdata.youtube.com/feeds/api/videos/"
        params='{"alt":"json", "q":"chrome"}'
        handleAs="json"
        on-core-response="{{handleResponse}}"></core-ajax>

With `auto` set to `true`, the element performs a request whenever
its `url` or `params` properties are changed.

Note: The `params` attribute must be double quoted JSON.

You can trigger a request explicitly by calling `go` on the
element.

@element core-ajax
@status beta
@homepage github.io
-->
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
/**
 * @group Polymer Core Elements
 *
 * core-xhr can be used to perform XMLHttpRequests.
 *
 *     <core-xhr id="xhr"></core-xhr>
 *     ...
 *     this.$.xhr.request({url: url, params: params, callback: callback});
 *
 * @element core-xhr
 */
-->

<!-- did not import ../polymer/polymer.html-->

<polymer-element name="core-xhr" hidden>

  <script>

    Polymer('core-xhr', {

      /**
       * Sends a HTTP request to the server and returns the XHR object.
       *
       * @method request
       * @param {Object} inOptions
       *    @param {String} inOptions.url The url to which the request is sent.
       *    @param {String} inOptions.method The HTTP method to use, default is GET.
       *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously. To send synchronous requests, set to true.
       *    @param {Object} inOptions.params Data to be sent to the server.
       *    @param {Object} inOptions.body The content for the request body for POST method.
       *    @param {Object} inOptions.headers HTTP request headers.
       *    @param {String} inOptions.responseType The response type. Default is 'text'.
       *    @param {boolean} inOptions.withCredentials Whether or not to send credentials on the request. Default is false.
       *    @param {Object} inOptions.callback Called when request is completed.
       * @returns {Object} XHR object.
       */
      request: function(options) {
        var xhr = new XMLHttpRequest();
        var url = options.url;
        var method = options.method || 'GET';
        var async = !options.sync;
        //
        var params = this.toQueryString(options.params);
        if (params && method == 'GET') {
          url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        var xhrParams = this.isBodyMethod(method) ? (options.body || params) : null;
        //
        xhr.open(method, url, async);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        if (options.withCredentials) {
          xhr.withCredentials = true;
        }
        this.makeReadyStateHandler(xhr, options.callback);
        this.setRequestHeaders(xhr, options.headers);
        xhr.send(xhrParams);
        if (!async) {
          xhr.onreadystatechange(xhr);
        }
        return xhr;
      },
    
      toQueryString: function(params) {
        var r = [];
        for (var n in params) {
          var v = params[n];
          n = encodeURIComponent(n);
          r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
        }
        return r.join('&');
      },

      isBodyMethod: function(method) {
        return this.bodyMethods[(method || '').toUpperCase()];
      },
      
      bodyMethods: {
        POST: 1,
        PUT: 1,
        DELETE: 1
      },

      makeReadyStateHandler: function(xhr, callback) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            callback && callback.call(null, xhr.response, xhr);
          }
        };
      },

      setRequestHeaders: function(xhr, headers) {
        if (headers) {
          for (var name in headers) {
            xhr.setRequestHeader(name, headers[name]);
          }
        }
      }

    });

  </script>
  
</polymer-element>

<polymer-element name="core-ajax" hidden attributes="url handleAs auto params response error method headers body contentType withCredentials">
<script>

  Polymer('core-ajax', {
    /**
     * Fired when a response is received.
     *
     * @event core-response
     */

    /**
     * Fired when an error is received.
     *
     * @event core-error
     */

    /**
     * Fired whenever a response or an error is received.
     *
     * @event core-complete
     */

    /**
     * The URL target of the request.
     *
     * @attribute url
     * @type string
     * @default ''
     */
    url: '',

    /**
     * Specifies what data to store in the `response` property, and
     * to deliver as `event.response` in `response` events.
     *
     * One of:
     *
     *    `text`: uses `XHR.responseText`.
     *
     *    `xml`: uses `XHR.responseXML`.
     *
     *    `json`: uses `XHR.responseText` parsed as JSON.
     *
     *    `arraybuffer`: uses `XHR.response`.
     *
     *    `blob`: uses `XHR.response`.
     *
     *    `document`: uses `XHR.response`.
     *
     * @attribute handleAs
     * @type string
     * @default 'text'
     */
    handleAs: '',

    /**
     * If true, automatically performs an Ajax request when either `url` or `params` changes.
     *
     * @attribute auto
     * @type boolean
     * @default false
     */
    auto: false,

    /**
     * Parameters to send to the specified URL, as JSON.
     *
     * @attribute params
     * @type string (JSON)
     * @default ''
     */
    params: '',

    /**
     * The response for the most recently made request, or null if it hasn't
     * completed yet or the request resulted in error.
     *
     * @attribute response
     * @type Object
     * @default null
     */
    response: null,

    /**
     * The error for the most recently made request, or null if it hasn't
     * completed yet or the request resulted in success.
     *
     * @attribute error
     * @type Object
     * @default null
     */
    error: null,

    /**
     * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
     * Default is 'GET'.
     *
     * @attribute method
     * @type string
     * @default ''
     */
    method: '',

    /**
     * HTTP request headers to send.
     *
     * Example:
     *
     *     <core-ajax
     *         auto
     *         url="http://somesite.com"
     *         headers='{"X-Requested-With": "XMLHttpRequest"}'
     *         handleAs="json"
     *         on-core-response="{{handleResponse}}"></core-ajax>
     *
     * @attribute headers
     * @type Object
     * @default null
     */
    headers: null,

    /**
     * Optional raw body content to send when method === "POST".
     *
     * Example:
     *
     *     <core-ajax method="POST" auto url="http://somesite.com"
     *         body='{"foo":1, "bar":2}'>
     *     </core-ajax>
     *
     * @attribute body
     * @type Object
     * @default null
     */
    body: null,

    /**
     * Content type to use when sending data.
     *
     * @attribute contentType
     * @type string
     * @default 'application/x-www-form-urlencoded'
     */
    contentType: 'application/x-www-form-urlencoded',

    /**
     * Set the withCredentials flag on the request.
     *
     * @attribute withCredentials
     * @type boolean
     * @default false
     */
    withCredentials: false,

    /**
     * Additional properties to send to core-xhr.
     *
     * Can be set to an object containing default properties
     * to send as arguments to the `core-xhr.request()` method
     * which implements the low-level communication.
     *
     * @property xhrArgs
     * @type Object
     * @default null
     */
    xhrArgs: null,

    ready: function() {
      this.xhr = document.createElement('core-xhr');
    },

    receive: function(response, xhr) {
      if (this.isSuccess(xhr)) {
        this.processResponse(xhr);
      } else {
        this.processError(xhr);
      }
      this.complete(xhr);
    },

    isSuccess: function(xhr) {
      var status = xhr.status || 0;
      return !status || (status >= 200 && status < 300);
    },

    processResponse: function(xhr) {
      var response = this.evalResponse(xhr);
      if (xhr === this.activeRequest) {
        this.response = response;
      }
      this.fire('core-response', {response: response, xhr: xhr});
    },

    processError: function(xhr) {
      var response = xhr.status + ': ' + xhr.responseText;
      if (xhr === this.activeRequest) {
        this.error = response;
      }
      this.fire('core-error', {response: response, xhr: xhr});
    },

    complete: function(xhr) {
      this.fire('core-complete', {response: xhr.status, xhr: xhr});
    },

    evalResponse: function(xhr) {
      return this[(this.handleAs || 'text') + 'Handler'](xhr);
    },

    xmlHandler: function(xhr) {
      return xhr.responseXML;
    },

    textHandler: function(xhr) {
      return xhr.responseText;
    },

    jsonHandler: function(xhr) {
      var r = xhr.responseText;
      try {
        return JSON.parse(r);
      } catch (x) {
        console.warn('core-ajax caught an exception trying to parse response as JSON:');
        console.warn('url:', this.url);
        console.warn(x);
        return r;
      }
    },

    documentHandler: function(xhr) {
      return xhr.response;
    },

    blobHandler: function(xhr) {
      return xhr.response;
    },

    arraybufferHandler: function(xhr) {
      return xhr.response;
    },

    urlChanged: function() {
      if (!this.handleAs) {
        var ext = String(this.url).split('.').pop();
        switch (ext) {
          case 'json':
            this.handleAs = 'json';
            break;
        }
      }
      this.autoGo();
    },

    paramsChanged: function() {
      this.autoGo();
    },

    autoChanged: function() {
      this.autoGo();
    },

    // TODO(sorvell): multiple side-effects could call autoGo
    // during one micro-task, use a job to have only one action
    // occur
    autoGo: function() {
      if (this.auto) {
        this.goJob = this.job(this.goJob, this.go, 0);
      }
    },

    /**
     * Performs an Ajax request to the specified URL.
     *
     * @method go
     */
    go: function() {
      var args = this.xhrArgs || {};
      // TODO(sjmiles): we may want XHR to default to POST if body is set
      args.body = this.body || args.body;
      args.params = this.params || args.params;
      if (args.params && typeof(args.params) == 'string') {
        args.params = JSON.parse(args.params);
      }
      args.headers = this.headers || args.headers || {};
      if (args.headers && typeof(args.headers) == 'string') {
        args.headers = JSON.parse(args.headers);
      }
      var hasContentType = Object.keys(args.headers).some(function (header) {
        return header.toLowerCase() === 'content-type';
      });
      if (!hasContentType && this.contentType) {
        args.headers['Content-Type'] = this.contentType;
      }
      if (this.handleAs === 'arraybuffer' || this.handleAs === 'blob' ||
          this.handleAs === 'document') {
        args.responseType = this.handleAs;
      }
      args.withCredentials = this.withCredentials;
      args.callback = this.receive.bind(this);
      args.url = this.url;
      args.method = this.method;

      this.response = this.error = null;
      this.activeRequest = args.url && this.xhr.request(args);
      return this.activeRequest;
    }

  });

</script>
</polymer-element>


<polymer-element name="grid-cell" on-click="{{cellClicked}}" on-dblclick="{{cellDoubleClicked}}">
  
  <template>
    <content></content>
  </template>
  
</polymer-element>

<polymer-element name="grid-header" on-click="{{headerClicked}}" on-dblclick="{{headerDoubleClicked}}">
  
  <template>
    <content></content>
  </template>
  
</polymer-element>

<polymer-element name="grid-sort-header" attributes="col direction sortprop active" on-click="{{ toggleDirection }}">

  <template>
    <content></content>  
    <content select="[sort-icon]"></content>  
  </template>

</polymer-element>

<polymer-element name="grid-sort-icon" attributes="direction">  
  
  <template>    
    <style>:host {
  height: 100%;
  display: block;
}
[hide] {
  display: none;
}
grid-header {
  text-transform: capitalize;
  font-weight: bold;
  height: 38px;
}
grid {
  display: block;
  height: 100%;
  font-family: arial;
}
grid grid-body {
  display: block;
  height: calc(100% - 38px );
}
grid grid-row {
  display: block;
  box-sizing: border-box;
  border: solid 1px #e2e2e2;
  border-top: none;
}
grid grid-cell,
grid grid-header-item {
  display: block;
  padding: 10px;
  box-sizing: border-box;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
grid grid-cell:hover,
grid grid-header-item:hover {
  border-radius: 5px;
  z-index: 9800;
}
grid grid-cell {
  height: 100%;
  cursor: pointer;
}
grid grid-sort-header {
  display: flex;
  justify-content: space-between;
}
grid grid-sort-header div {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
grid grid-sort-icon {
  float: right;
}
core-list {
  height: 100%;
}
[sort-asc]:before {
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  transform: rotate(180deg);
  content: "\25be";
  display: inline-block;
  cursor: pointer;
}
[sort]:before {
  content: "\2b0d";
  cursor: pointer;
}
[sort-desc]:before {
  content: "\25be";
  cursor: pointer;
}
</style>    
    <icon sort-asc="" hide?="{{ direction != &apos;asc&apos; }}"></icon>
    <icon sort-desc="" hide?="{{ direction != &apos;desc&apos; }}"></icon>
    <icon sort="" hide?="{{ direction }}"></icon>
  </template>

</polymer-element>

<polymer-element name="ui-table" attributes="value sort url rowheight src ignoredcols headers" on-grid-sort="{{sortColumn}}">
    
  <template>
    <style>:host {
  height: 100%;
  display: block;
}
[hide] {
  display: none;
}
grid-header {
  text-transform: capitalize;
  font-weight: bold;
  height: 38px;
}
grid {
  display: block;
  height: 100%;
  font-family: arial;
}
grid grid-body {
  display: block;
  height: calc(100% - 38px );
}
grid grid-row {
  display: block;
  box-sizing: border-box;
  border: solid 1px #e2e2e2;
  border-top: none;
}
grid grid-cell,
grid grid-header-item {
  display: block;
  padding: 10px;
  box-sizing: border-box;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
grid grid-cell:hover,
grid grid-header-item:hover {
  border-radius: 5px;
  z-index: 9800;
}
grid grid-cell {
  height: 100%;
  cursor: pointer;
}
grid grid-sort-header {
  display: flex;
  justify-content: space-between;
}
grid grid-sort-header div {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
grid grid-sort-icon {
  float: right;
}
core-list {
  height: 100%;
}
[sort-asc]:before {
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  transform: rotate(180deg);
  content: "\25be";
  display: inline-block;
  cursor: pointer;
}
[sort]:before {
  content: "\2b0d";
  cursor: pointer;
}
[sort-desc]:before {
  content: "\25be";
  cursor: pointer;
}
</style>
    <!-- content select out the overrides for default cell renderers -->    
    <content id="cell-default-override" select="[cell-default]"></content>
    <content id="columnOverrides" select="[column]"></content>
    <template id="header-default">
      <grid-header-item flex="" title="{{header}}">
        <grid-sort-header sortprop="{{header}}" active="true" col="{{header}}">
          <div>
            {{ header }}
          </div> 
          <grid-sort-icon sort-icon=""></grid-sort-icon>          
        </grid-sort-header>
      </grid-header-item>
    </template>
    <template id="row-default">
      <grid-row horizontal="" layout="" style="height: {{ rowheight }}px;">
        <template repeat="{{ key in row | keys | remove(ignoredcols) }}">
          <grid-cell flex="" title="{{ row[key] }}" class="{{key}}">
            <template ref="{{userDefinedTemplates | findTemplate(key)}}" bind="{{}}"></template>
          </grid-cell>
        </template>
      </grid-row>
    </template>

    <template id="cell-default">      
      {{ row[key] }}
    </template>

    <grid>                
      <grid-header horizontal="" layout="">
        <template repeat="{{ header in headers | remove(_ignoredcols) }}" ref="header-default"></template>        
      </grid-header> 
      <grid-body>  
        <core-list data="{{ _value }}" height="{{ rowheight }}">
          <template ref="row-default"></template>
        </core-list>      
      </grid-body>
    </grid>

    <core-ajax auto="" url="{{src}}" handleas="json" on-core-response="{{updateValue}}"></core-ajax>

  </template>

</polymer-element>

<script built="/Users/sbazli/github/ui-table/src/ui-table.litcoffee">(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
PolymerExpressions.prototype.keys = function(o) {
  return Object.keys(o);
};

PolymerExpressions.prototype.remove = function(arr, remove) {
  if (!((arr != null ? arr.length : void 0) && (remove != null ? remove.length : void 0))) {
    return arr;
  }
  return arr.filter(function(a) {
    return !!remove.indexOf(a);
  });
};

PolymerExpressions.prototype.findTemplate = function(userDefinedTemplates, key) {
  var cellTemplate;
  cellTemplate = 'cell-default';
  userDefinedTemplates.array().forEach(function(i) {
    if (i.getAttribute('name') === key) {
      return cellTemplate = "" + key + "-column";
    }
  });
  return cellTemplate;
};

Polymer('grid-sort-icon', {});

Polymer('grid-cell', {
  cellClicked: function() {
    return this.fire('grid-cell-click', this.templateInstance.model);
  },
  cellDoubleClicked: function() {
    return this.fire('grid-cell-double-click', this.templateInstance.model);
  }
});

Polymer('grid-header', {
  headerClicked: function() {
    return this.fire('grid-header-click', this.templateInstance.model);
  },
  headerDoubleClicked: function() {
    return this.fire('grid-header-double-click', this.templateInstance.model);
  }
});

Polymer('grid-sort-header', {
  directionChanged: function() {
    this.applySort();
    return this.updateIcon();
  },
  sortpropChanged: function() {
    return this.applySort();
  },
  colChanged: function() {
    return this.applySort();
  },
  updateIcon: function() {
    var sortIcon;
    sortIcon = this.querySelector('[sort-icon]');
    return sortIcon != null ? sortIcon.setAttribute('direction', this.direction) : void 0;
  },
  applySort: function() {
    var _ref;
    if (!(((_ref = this.direction) != null ? _ref.length : void 0) && this.sortprop && this.active)) {
      return;
    }
    return this.fire('grid-sort', {
      direction: this.direction,
      prop: this.sortprop,
      col: this.col
    });
  },
  toggleDirection: function(event, detail, element) {
    this.direction = this.direction === 'asc' ? 'desc' : 'asc';
    return this.active = true;
  }
});

Polymer('ui-table', {
  sortFunctions: {
    asc: function(a, b) {
      if (a === void 0 || a === '' || a === null) {
        return 1;
      }
      if (b === void 0 || b === '' || b === null) {
        return -1;
      }
      if (typeof a === 'string') {
        a = a.toLowerCase().trim();
      }
      if (typeof b === 'string') {
        b = b.toLowerCase().trim();
      }
      if (a > b) {
        return 1;
      }
      if (a < b) {
        return -1;
      }
      return 0;
    },
    desc: function(a, b) {
      if (a === void 0 || a === '' || a === null) {
        return 1;
      }
      if (b === void 0 || b === '' || b === null) {
        return -1;
      }
      if (typeof a === 'string') {
        a = a.toLowerCase().trim();
      }
      if (typeof b === 'string') {
        b = b.toLowerCase().trim();
      }
      if (a < b) {
        return 1;
      }
      if (a > b) {
        return -1;
      }
      return 0;
    }
  },
  sortChanged: function() {
    return this.applySort();
  },
  ignoredcolsChanged: function() {
    this._ignoredcols = this.ignoredcols;
    if (typeof this.ignoredcols === 'string') {
      this._ignoredcols = this.ignoredcols.split(',');
    }
    return this.rebuildValue();
  },
  rowheightChanged: function(oldVal, newVal) {
    if (!this._rowheight) {
      this._rowheight = newVal ? newVal : -1;
    }
    return this.rebuildValue();
  },
  valueChanged: function() {
    this.rebuildValue();
    this.rebuildHeader();
    this.applySort();
    return this.fire('grid-value-changed', {
      tableId: this.id
    });
  },
  updateValue: function(event) {
    var res;
    res = event.detail.response;
    if (this.transformResponse) {
      return this.value = this.transformResponse(res);
    }
    return this.value = res;
  },
  rebuildValue: function() {
    return this._value = (this.value || []).slice(0).map((function(_this) {
      return function(v, k) {
        return {
          row: v,
          rowheight: _this.rowheight,
          ignoredcols: _this._ignoredcols,
          userDefinedTemplates: _this.userDefinedTemplates,
          tableId: _this.id
        };
      };
    })(this));
  },
  rebuildHeader: function() {
    return this.headers = Object.keys(this._value.reduce(function(acc, wrapped) {
      Object.keys(wrapped.row).forEach(function(k) {
        return acc[k] = true;
      });
      return acc;
    }, {}));
  },
  sortColumn: function(event, descriptor) {
    return this.sort = descriptor;
  },
  updateHeaders: function() {
    var sortables, _ref;
    sortables = (_ref = this.shadowRoot) != null ? _ref.querySelectorAll("grid-sort-header") : void 0;
    return sortables != null ? sortables.array().forEach((function(_this) {
      return function(sortable) {
        if (sortable.col !== _this.sort.col) {
          sortable.setAttribute('active', false);
          return sortable.direction = '';
        }
      };
    })(this)) : void 0;
  },
  applySort: function() {
    if (!(this._value && this.sort)) {
      return;
    }
    this.updateHeaders();
    return this._value.sort((function(_this) {
      return function(a, b) {
        var compare, d, left, right;
        d = _this.sort;
        compare = _this.sortFunctions[d.direction];
        left = _this.propParser(a.row, d.prop);
        right = _this.propParser(b.row, d.prop);
        return compare(left, right);
      };
    })(this));
  },
  addTemplates: function(nodes, type) {
    return nodes.getDistributedNodes().array().forEach((function(_this) {
      return function(t) {
        var col;
        col = t.getAttribute('name');
        t.setAttribute('id', "" + col + "-" + type);
        return _this.shadowRoot.appendChild(t);
      };
    })(this));
  },
  ready: function() {
    var cellDefaultOverride, t, _ref;
    this.addTemplates(this.$.columnOverrides, 'column');
    this.userDefinedTemplates = this.shadowRoot.querySelectorAll('template[column]');
    cellDefaultOverride = (_ref = this.$['cell-default-override'].getDistributedNodes().array()) != null ? _ref[0] : void 0;
    if (cellDefaultOverride) {
      this.shadowRoot.removeChild(this.$['cell-default']);
      t = document.createElement('template');
      t.setAttribute('id', 'cell-default');
      t.innerHTML = cellDefaultOverride.innerHTML;
      return this.shadowRoot.appendChild(t);
    }
  },
  propParser: function(doc, prop) {
    return prop.split('.').reduce(function(acc, p) {
      return acc[p];
    }, doc);
  }
});



},{}]},{},[1])</script>